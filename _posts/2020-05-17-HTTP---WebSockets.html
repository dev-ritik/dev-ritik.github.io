---
title: HTTP & WebSockets
date: 2020-05-17
layout: post
medium: https://medium.com/mobile-development-group/http-websockets-9c6704e44a2a
---
<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>HTTP &amp; WebSockets</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">HTTP &amp; WebSockets</h1>
</header>
<section data-field="subtitle" class="p-summary">
How are they connected to sockets? How is HTTP evolving? HTTP/2? HTTP/3? QUIC? Is WebSockets the same as Sockets?…
</section>
<section data-field="body" class="e-content">
<section name="23cf" class="section section--body section--first"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="3788" id="3788" class="graf graf--h3 graf--leading graf--title">HTTP &amp; WebSockets</h3><p name="7ffa" id="7ffa" class="graf graf--p graf--hasDropCapModel graf--hasDropCap graf-after--h3"><span class="graf-dropCap">In</span> the last blog, <a href="https://medium.com/mobile-development-group/simple-servers-cc465f340658" data-href="https://medium.com/mobile-development-group/simple-servers-cc465f340658" class="markup--anchor markup--p-anchor" target="_blank">Simple Servers</a>, I covered sockets based communication, which is very low implementation. Thus these are not the things you would be interacting with directly while writing servers today. <em class="markup--em markup--p-em">They probably would be HTTP &amp; HTTPS!</em>.</p><p name="6fd5" id="6fd5" class="graf graf--p graf-after--p">Today, the world works on HTTP. The entire consumer internet infrastructure, with terabytes of data, moved across networks every second to these devices in our hands, is constituted mostly by HTTP &amp; WebSocket.</p><blockquote name="8ceb" id="8ceb" class="graf graf--pullquote graf-after--p">OK! so how are they related to sockets? How is HTTP evolving? Is WebSockets the same as Sockets?</blockquote><blockquote name="76fc" id="76fc" class="graf graf--blockquote graf-after--pullquote">I will explain the key concepts with examples related to them, while avoiding as much technical jargon as possible.</blockquote><!--break--><p name="7afe" id="7afe" class="graf graf--p graf-after--blockquote"><strong class="markup--strong markup--p-strong">Prerequisites</strong></p><p name="9ea4" id="9ea4" class="graf graf--p graf-after--p">A little knowledge of network systems with interest in the topic should be just excellent. Have a look at my <a href="https://medium.com/mobile-development-group/simple-servers-cc465f340658" data-href="https://medium.com/mobile-development-group/simple-servers-cc465f340658" class="markup--anchor markup--p-anchor" target="_blank">last blog</a> for some basic concepts.</p><h3 name="7bd3" id="7bd3" class="graf graf--h3 graf-after--p">Introduction to HTTP and its versions</h3><p name="c22b" id="c22b" class="graf graf--p graf-after--h3">Once a socket-based connection is made, the client and the server can indeed communicate with each other. If it were for your inhouse application, any form of communication standards would suffice. But, when it comes to standardizing a protocol for communication between the browsers and the servers, <em class="markup--em markup--p-em">it ought to be simple and extensible</em>. As you might know, <strong class="markup--strong markup--p-strong">HTTP</strong> plays that role. It is the underlying application-level protocol which defines this communication.</p><p name="8c4a" id="8c4a" class="graf graf--p graf-after--p">Whenever a browser wants a web page, it sends an HTTP request to get that page. The server responds according to this protocol and sends the page and an appropriate HTTP status code which can be interpreted by the browser as the standard server’s response. Its versatility and usefulness are reflected on its extensive use even now (since<strong class="markup--strong markup--p-strong"> </strong>the 1990s). Today, a wide range of applications (<em class="markup--em markup--p-em">almost just about anything you can think of</em>) are deployed over HTTP.</p><p name="22dc" id="22dc" class="graf graf--p graf-after--p">HTTP is a request/response protocol. The client sends a request to the server in the form of a request method, URI, and protocol version, followed by a message containing request modifiers, client information, and possible body content over the connection. The server responds with a status line, including the message’s protocol version and a success or error code, followed by a message containing server information, entity metainformation, and possible entity-body content.</p><h4 name="fbc4" id="fbc4" class="graf graf--h4 graf-after--p">Features</h4><ul class="postList"><li name="aff3" id="aff3" class="graf graf--li graf-after--h4">HTTP by itself is <strong class="markup--strong markup--li-strong">stateless</strong>. This means each request is executed independently, without any knowledge of the requests that were executed before it, i.e. the server does not keep any state between two requests. Even though servers use cookies today to store state, HTTP remains stateless</li><li name="5022" id="5022" class="graf graf--li graf-after--li">The applications can easily modify it by adding custom headers, which the client and the server agrees upon.</li><li name="8e21" id="8e21" class="graf graf--li graf-after--li">It is reliable (ensures the message is transferred or generates an error).</li><li name="a12f" id="a12f" class="graf graf--li graf-after--li">HTTP/1.x, it is pretty easy to implement, something which I demonstrated in my <a href="https://medium.com/mobile-development-group/simple-servers-cc465f340658" data-href="https://medium.com/mobile-development-group/simple-servers-cc465f340658" class="markup--anchor markup--li-anchor" target="_blank">socket blog</a>.</li></ul><h4 name="2135" id="2135" class="graf graf--h4 graf-after--li">Versions</h4><p name="fe9f" id="fe9f" class="graf graf--p graf-after--h4">Take the simplest example of <strong class="markup--strong markup--p-strong">HTML/0.9</strong> (the initially proposed version). As simple as making a TCP Socket connection and sending one-line ASCII request</p><pre name="4045" id="4045" class="graf graf--pre graf-after--p"><code class="markup--code markup--pre-code">GET /index.html</code></pre><p name="99e6" id="99e6" class="graf graf--p graf-after--pre">to the socket will get you the response hypertext message from the server socket</p><pre name="1fa7" id="1fa7" class="graf graf--pre graf-after--p">&lt;HTML&gt;<br>  &lt;Body&gt;<br>   &lt;h1&gt;<br>     Hello from server!<br>   &lt;/h1&gt;<br>  &lt;/Body&gt;<br>&lt;/HTML&gt;</pre><p name="12bb" id="12bb" class="graf graf--p graf-after--pre">and the connection will be closed.</p><p name="291a" id="291a" class="graf graf--p graf-after--p">HTTP has had several revisions since. <strong class="markup--strong markup--p-strong">HTTP/1.0 </strong>modified HTTP/0.9 and added features like status code headers, version (appended in the 1st line).</p><p name="1a4f" id="1a4f" class="graf graf--p graf-after--p">Standardised in <strong class="markup--strong markup--p-strong">HTTP/1.1</strong>, it is the most widely used version right now. It introduced connection reuse, among other things. Opening and closing a connection is a significant overhead in a TCP connection. With the introduction of SSL/TLS Handshake, the number of message exchanges for establishing a connection has gone significantly up, increasing the load on HTTP servers apart from causing congestion on the Internet and the apparent delay. By persisting a connection, memory &amp; CPU time is conserved as well. These warm existing connections overcome <strong class="markup--strong markup--p-strong">TCP slow start</strong> congestion control protocol as well. Hence, it’s wasteful if used for just a single request-response exchange connection.</p><p name="3066" id="3066" class="graf graf--p graf-after--p">Using <strong class="markup--strong markup--p-strong">persistent connections</strong>, multiple HTTP requests could be sent in the same connection (connection is ‘<em class="markup--em markup--p-em">keepalive</em>’ by default). This allowed connection to be reused, but the problem remained that newer requests had to wait for the response of the existing one in a particular connection(a strict FIFO from the client-side).</p><figure name="1ab6" id="1ab6" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*5I7UTS1pOwlHwv_vAaLP3g.png" data-width="1012" data-height="670" src="https://cdn-images-1.medium.com/max/800/1*5I7UTS1pOwlHwv_vAaLP3g.png"><figcaption class="imageCaption"><a href="http://developer.mozilla.org" data-href="http://developer.mozilla.org" class="markup--anchor markup--figure-anchor" rel="noopener" target="_blank">Courtesy</a></figcaption></figure><p name="5d62" id="5d62" class="graf graf--p graf-after--figure">It introduced <strong class="markup--strong markup--p-strong">request pipelining</strong> as well wherein, multiple requests could be sent instead of waiting for the response of the first one to arrive, on the same connection. Modern-day webpages request tons of other static assets as well upon loading. Pipelining them on the same connection makes sense as well. But this increases the load of buffering and processing on the server’s end. As you can see in the picture, the server can only send the response to a request in a FIFO manner. Multiplexing was still not introduced for helping with multiple parallel responses. This has some other severe implications in TCP based connection as well. Therefore pipelining is in marginal use today.</p><p name="e5b6" id="e5b6" class="graf graf--p graf-after--p">In such a scenario, browsers have limited choice for handling tons of static resources put into displaying today’s web pages. They have to make a balance between the number of parallel connections and FIFO delay. (Throwing unlimited connection may lead to unintentional D-DoS). In practice, browsers tend to open around 6 connections per host, but there is a good discussion around <a href="https://bugs.chromium.org/p/chromium/issues/detail?id=12066" data-href="https://bugs.chromium.org/p/chromium/issues/detail?id=12066" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">that</a>. From <a href="https://tools.ietf.org/html/rfc2616#section-8.1.4" data-href="https://tools.ietf.org/html/rfc2616#section-8.1.4" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">RFC 2616</a>, “<em class="markup--em markup--p-em">Clients that use persistent connections SHOULD limit the number of simultaneous connections that they maintain to a given server. A single-user client SHOULD NOT maintain more than 2 connections with any server or proxy</em>”.</p><figure name="e069" id="e069" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*YJfWLxUhF9BvHYZUSQPp0w.png" data-width="945" data-height="406" src="https://cdn-images-1.medium.com/max/800/1*YJfWLxUhF9BvHYZUSQPp0w.png"><figcaption class="imageCaption">Waterfall for the same <em class="markup--em markup--figure-em">domain</em> using HTTP/1.1</figcaption></figure><p name="dc31" id="dc31" class="graf graf--p graf-after--figure">You can verify this using the <em class="markup--em markup--p-em">inspect-network</em> tool in the (chrome) browser. Notice how only 6 parallel connections are made (to the same host) and other requests are waiting for the response to the earlier ones.</p><p name="9b46" id="9b46" class="graf graf--p graf-after--p">There is yet another problem with HTTP/1.x. When considering tons of HTTP calls for a single page rendering, everything matters. If you notice, we are exchanging a bunch of metadata including headers and cookies(which by the stateless nature needs to be sent with all of your requests) which fundamentally increase the total payload for the transport layer. These are sent as plain text without compression. Run the command:</p><pre name="b786" id="b786" class="graf graf--pre graf-after--p">curl --trace-ascii - \<br>&#39;<a href="http://postman-echo.com/get?foo1=bar1&amp;foo2=bar2%27" data-href="http://postman-echo.com/get?foo1=bar1&amp;foo2=bar2&#39;" class="markup--anchor markup--pre-anchor" rel="nofollow noopener noopener noopener" target="_blank">http://postman-echo.com/get?foo1=bar1&amp;foo2=bar2&#39;</a></pre><p name="f908" id="f908" class="graf graf--p graf-after--pre">You can see that the header to data byte ratio in the request is 103:0, whereas in response is 352:227. Headers clearly overshadow the actual HTTP payload.</p><p name="e7c6" id="e7c6" class="graf graf--p graf-after--p">Come <a href="https://tools.ietf.org/html/rfc7540" data-href="https://tools.ietf.org/html/rfc7540" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank"><strong class="markup--strong markup--p-strong">HTTP/2.0</strong></a>, many of these problems were addressed. Essentially it adds a new intermediate <strong class="markup--strong markup--p-strong">binary framing layer</strong> between the HTTP/1.x syntax and the underlying transport protocol, without fundamentally modifying it. With the introduction of <strong class="markup--strong markup--p-strong">multiplexing</strong> transfers, multiple requests could be sent simultaneously in the same TCP connection with each request being largely independent of others in the form of separate <strong class="markup--strong markup--p-strong">streams</strong>. These streams are just a bidirectional flow of HTTP/2 <strong class="markup--strong markup--p-strong">frames</strong>, identifiable by assigned integers. Multiple streams can be initiated and used at the same time within the same connection, thus establishing multiplexing.</p><figure name="1f58" id="1f58" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*IOHUOmufilOT7nwpAAhnbA.png" data-width="868" data-height="451" src="https://cdn-images-1.medium.com/max/800/1*IOHUOmufilOT7nwpAAhnbA.png"><figcaption class="imageCaption"><a href="http://developers.google.com" data-href="http://developers.google.com" class="markup--anchor markup--figure-anchor" rel="noopener" target="_blank">Courtesy</a></figcaption></figure><p name="4ae7" id="4ae7" class="graf graf--p graf-after--figure">The basic protocol unit in HTTP/2 is a <strong class="markup--strong markup--p-strong">frame</strong>. There are quite a few types of frame, including HEADERS and DATA frame. The format of frames is well defined in <a href="https://tools.ietf.org/html/rfc7540#section-4.1" data-href="https://tools.ietf.org/html/rfc7540#section-4.1" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">RFC 7540</a>. Along with other stuff, these frames carry a <strong class="markup--strong markup--p-strong">stream identifier</strong>, necessary while multiplexing wherein these frames of different streams can be interleaved and then reassembled. In the HEADERS frame, headers are compressed and serialised into a header block using <a href="https://tools.ietf.org/html/rfc7541" data-href="https://tools.ietf.org/html/rfc7541" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank"><strong class="markup--strong markup--p-strong">HPACK</strong></a><strong class="markup--strong markup--p-strong"> compression</strong>. Often these header names and values are the same or similar. It uses Huffman encoding and static and dynamic reference tables for this purpose. Same headers among consecutive frames can be simply referenced using the dynamic table and duplicates can be dropped. You can get a feeling of how this would be done and feel the compression gain as well. Header frames may also contain a weight field, assigning <strong class="markup--strong markup--p-strong">priority</strong> to the requests. This prioritisation will help in getting crucial assets like CSS and blocking JS faster, thus improving performance.</p><p name="498a" id="498a" class="graf graf--p graf-after--p">With the introduction of <strong class="markup--strong markup--p-strong">server push</strong>, servers can push additional resources to the client which it knows the client would request for. The server can send these in additional multiple responses (in new push streams) for the single request. This indeed helps in saving request latencies in RTT (Round Trip Time). For example, the server may push all the relevant assets when it receives a request for the index page, which the client can cache.</p><p name="ff3a" id="ff3a" class="graf graf--p graf-after--p">Standardised in 2015, HTTP/2 has seen wide adoption, particularly with high traffic servers. The protocol requires no change from the web application but only an upgrade to the browser and the server. The application side API remains the same with the same semantics. Because the data is transferred using binary instead of text, <strong class="markup--strong markup--p-strong">tcpdump</strong> cannot be used to read the data directly. As such it can run with TLS or as cleartext TCP but is generally used with HTTPS.</p><p name="4b52" id="4b52" class="graf graf--p graf-after--p">Check the latest implementations of HTTP/2 <a href="https://github.com/http2/http2-spec/wiki/Implementations" data-href="https://github.com/http2/http2-spec/wiki/Implementations" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">here</a>. As a fact, Medium is using H2 as of now!</p><h4 name="03cb" id="03cb" class="graf graf--h4 graf-after--p">Implementation</h4><figure name="9fe5" id="9fe5" class="graf graf--figure graf-after--h4"><img class="graf-image" data-image-id="1*eJTGH8nj-cCxdURQDa9OEA.png" data-width="970" data-height="403" src="https://cdn-images-1.medium.com/max/800/1*eJTGH8nj-cCxdURQDa9OEA.png"><figcaption class="imageCaption">Waterfall for the same host using H2</figcaption></figure><p name="a297" id="a297" class="graf graf--p graf-after--figure">Clearly HTTP/2 is vastly different wrt HTTP/1.1 (from the image far up), you can see that the time for the first two items remained almost similar (owing to the way the page is loaded), but after that 15 more assets are requested at the same time. You can see that in HTTP/1.1, requests were queued in 6 parallel TCP connections waiting for their turn, but here, all of them are requested at once (with set priorities) without waiting. Notice how the only JS request (3rd one) took less (626 ms) to load from the HTTP/1.1 (734 ms). This can be attributed to high priority being assigned to the blocking JS assets by chrome. As for the increased size of the green bar (<code class="markup--code markup--p-code">time to first byte</code>) for others, it is because HTTP/2 prioritises critical JS assets for a better experience, so other requests have to wait for a while. Also, do note that the finish time is 2.30s in HTTP/1.1 vs 2.12s in H2</p><figure name="82ec" id="82ec" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*rPm-NkSfCdSaqFayQ_l0lg.png" data-width="878" data-height="391" data-is-featured="true" src="https://cdn-images-1.medium.com/max/800/1*rPm-NkSfCdSaqFayQ_l0lg.png"><figcaption class="imageCaption">With Server push</figcaption></figure><p name="13a5" id="13a5" class="graf graf--p graf-after--figure">For the image above, I pushed CSS and JS assets (2nd and 3rd, respectively) with the index page (1st request). Notice how it makes no network call for these resources as gets it from the cached files (pushed from server). This is a significant boost in performance and user experience wrt other images above.</p><p name="ed9f" id="ed9f" class="graf graf--p graf-after--p">Let’s move to the more recent and under-development, <strong class="markup--strong markup--p-strong">HTTP/3</strong> (HTTP over <strong class="markup--strong markup--p-strong">QUIC</strong>(<strong class="markup--strong markup--p-strong">Quick UDP Internet Connections</strong>)). Though much support is not available, popular browsers and servers are slowly adopting HTTP/3. QUIC, unlike other revisions, is somewhat radical. The whole concept is to shift the entire protocol from TCP to <strong class="markup--strong markup--p-strong">UDP</strong>! Yes, you read it right.</p><p name="0df2" id="0df2" class="graf graf--p graf-after--p">Owing to some of the limitations of the underlying TCP at the transport layer, it became crucial to think of modifying that protocol. But then modifying TCP would have required changes in the entire internet infrastructure. Therefore, this new transport layer protocol is built upon UDP and inherits properties from TCP with modifications as needed.</p><figure name="5324" id="5324" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*sQflnyUcKVFaGmagZ7GJrg.png" data-width="851" data-height="446" src="https://cdn-images-1.medium.com/max/800/1*sQflnyUcKVFaGmagZ7GJrg.png"><figcaption class="imageCaption"><a href="https://datatracker.ietf.org/meeting/98/materials/slides-98-edu-sessf-quic-tutorial-00.pdf" data-href="https://datatracker.ietf.org/meeting/98/materials/slides-98-edu-sessf-quic-tutorial-00.pdf" class="markup--anchor markup--figure-anchor" rel="noopener" target="_blank">Courtesy</a></figcaption></figure><p name="d25a" id="d25a" class="graf graf--p graf-after--figure">To count a few limitations of TCP, wrt HTTP/2.0:</p><ul class="postList"><li name="0d34" id="0d34" class="graf graf--li graf-after--p"><strong class="markup--strong markup--li-strong">Connection establishment latency:</strong> For a general TCP secure connection, it requires 2–3 RTT in handshakes whereas it can be done in 0–1 RTT in QUIC. It merges connection and encryption into a single handshake. If the client has talked to a given server before, it can start sending data without any round trip!</li></ul><figure name="acfb" id="acfb" class="graf graf--figure graf-after--li"><img class="graf-image" data-image-id="1*lfXH5BHQt_ltGCq-KEvlUQ.gif" data-width="600" data-height="381" src="https://cdn-images-1.medium.com/max/800/1*lfXH5BHQt_ltGCq-KEvlUQ.gif"><figcaption class="imageCaption"><a href="http://cloudplatform.googleblog.com" data-href="http://cloudplatform.googleblog.com" class="markup--anchor markup--figure-anchor" rel="noopener" target="_blank">Courtesy</a></figcaption></figure><ul class="postList"><li name="6813" id="6813" class="graf graf--li graf-after--figure"><strong class="markup--strong markup--li-strong">Encryption:</strong> QUIC comes with encryption built into it and negotiates the terms in its only Handshake (TLS 1.3). Connections are encrypted from the beginning.</li><li name="1f68" id="1f68" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Stream control: </strong>In HTTP/2, wherein multiple streams utilise a shared connection, the underlying TCP has no idea of these streams. Consequently, the transport layer values them as consecutive payload sent by the application layer. This can cause some limitation such as <strong class="markup--strong markup--li-strong">Head of Line Blocking </strong>wherein all the streams can be blocked until a previously on flight stream frame has not been received. This is essentially handled by bringing the pre-stream control to the underlying QUIC protocol.</li><li name="4517" id="4517" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Connection migration: </strong>Switching networks in HTTP/2 would mean inflight packets being dropped and the need to establish a new connection (because a socket is identified using IP address port pair). This would be handled in QUIC using a 64-bit connection ID. This will help a server identify a client even when the client changes its IP address (like switching to Wi-Fi from a cellular network).</li></ul><p name="b64b" id="b64b" class="graf graf--p graf-after--li">QUIC streams, like HTTP/2 streams, share the same connection. Additional control over independent streams provides additional advantages. Streams can now arrive out of order among each other and are not affected by network packet loss of another stream. However, this has to lead the HPACK algorithm to be modified into <strong class="markup--strong markup--p-strong">QPACK</strong> for HTTP/3, because this out of order delivery can cause some additional issues. QPACK uses separate unidirectional streams to modify and track header table state. The new HTTP/3 is built over this protocol. HTTP/3 streams simply run over QUIC streams. The semantics has not changed and is yet transparent to the application.</p><p name="7eb9" id="7eb9" class="graf graf--p graf-after--p graf--trailing">Much of the work is yet to be finalised, and various implementations spring up similar to the draft proposal. Check the latest implementations of QUIC HTTP/3 <a href="https://github.com/quicwg/base-drafts/wiki/Implementations" data-href="https://github.com/quicwg/base-drafts/wiki/Implementations" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">here</a>.</p></div></div></section><section name="e8cb" class="section section--body"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="66f9" id="66f9" class="graf graf--h3 graf--leading">Is WebSockets the same as Sockets?</h3><p name="ec00" id="ec00" class="graf graf--p graf-after--h3"><a href="https://tools.ietf.org/html/rfc6455" data-href="https://tools.ietf.org/html/rfc6455" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank"><strong class="markup--strong markup--p-strong">WebSocket</strong></a><strong class="markup--strong markup--p-strong"> </strong>is a communication<strong class="markup--strong markup--p-strong"> </strong>protocol that allows clients(like browsers) and servers to communicate on a full-duplex channel over a long time over TCP Sockets. Being based on a persistent TCP Socket connection, any of the client or the server can send data at any time until the connection is broken from either of the parties. Think about building a chat application. Pinging Server continuously for checking for new messages would be a waste of bandwidth and resources. The server should be able to respond by itself when it gets new data to send. This also differentiates WebSockets from HTTP persistent connections.</p><p name="a0b3" id="a0b3" class="graf graf--p graf-after--p">WebSockets and Network Sockets may sound similar but are quite different. While the latter is just a generic file descriptor to the file where the network writes the received data packets the former is a protocol built upon TCP Sockets. Network Socket, in general, is independent of the transport protocol(TCP or UDP).</p><p name="5660" id="5660" class="graf graf--p graf-after--p">This protocol requires a handshake over the established TCP Socket connection. The Handshake is based on simple HTTP request-response and an upgrade header and other related fields.</p><p name="390f" id="390f" class="graf graf--p graf-after--p">The handshake from the client looks as follows:</p><pre name="4d3f" id="4d3f" class="graf graf--pre graf-after--p">GET /chat HTTP/1.1<br>Host: server.example.com<br>Upgrade: websocket<br>Connection: Upgrade<br>Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==<br>Origin: <a href="http://example.com" data-href="http://example.com" class="markup--anchor markup--pre-anchor" rel="nofollow noopener noopener noopener" target="_blank">http://example.com</a><br>Sec-WebSocket-Protocol: chat, superchat<br>Sec-WebSocket-Version: 13</pre><p name="2aac" id="2aac" class="graf graf--p graf-after--pre">The handshake from the server looks as follows:</p><pre name="8963" id="8963" class="graf graf--pre graf-after--p">HTTP/1.1 101 Switching Protocols<br>Upgrade: websocket<br>Connection: Upgrade<br>Sec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+xOo=<br>Sec-WebSocket-Protocol: chat</pre><p name="4ddd" id="4ddd" class="graf graf--p graf-after--pre">If everything is fine, the connection is upgraded to a WebSocket connection after which any party can send data as required. Thereafter, the same connection is used for exchanging any further message. Various other control frames like PING, PONG, CLOSE are used to check/ close the connection</p><p name="df6d" id="df6d" class="graf graf--p graf-after--p graf--trailing">There are various libraries available to abstract the working of WebSockets.</p></div></div></section><section name="ab4b" class="section section--body section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h4 name="b0e8" id="b0e8" class="graf graf--h4 graf--leading">Conclusion</h4><p name="6dc6" id="6dc6" class="graf graf--p graf-after--h4">I hope you have understood these standard concepts. HTTP is indeed a promising one. I have covered how these are secured (HTTPS and TLS-SSL) in my next blog:</p><div name="f5da" id="f5da" class="graf graf--mixtapeEmbed graf-after--p"><a href="https://medium.com/mobile-development-group/trust-tls-ssl-and-https-b925ac9d59" data-href="https://medium.com/mobile-development-group/trust-tls-ssl-and-https-b925ac9d59" class="markup--anchor markup--mixtapeEmbed-anchor" title="https://medium.com/mobile-development-group/trust-tls-ssl-and-https-b925ac9d59"><strong class="markup--strong markup--mixtapeEmbed-strong">Trust! TLS-SSL and HTTPS</strong><br><em class="markup--em markup--mixtapeEmbed-em">How is the HTTP traffic secured? What does that lock indicate? How do we establish trust? How can I say that indeed medium.com…</em>medium.com</a><a href="https://medium.com/mobile-development-group/trust-tls-ssl-and-https-b925ac9d59" class="js-mixtapeImage mixtapeImage u-ignoreBlock" data-media-id="a810ae01624769ddceeeb146fc8ce365" data-thumbnail-img-id="1*iqCIxpXSNkgfjAw22I4Itw.png" style="background-image: url(https://cdn-images-1.medium.com/fit/c/160/160/1*iqCIxpXSNkgfjAw22I4Itw.png);"></a></div><p name="3a67" id="3a67" class="graf graf--p graf-after--mixtapeEmbed graf--trailing">See you there!</p></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@ritikk" class="p-author h-card">Ritik kumar</a> on <a href="https://medium.com/p/9c6704e44a2a"><time class="dt-published" datetime="2020-05-17T17:10:48.810Z">May 17, 2020</time></a>.</p><p><a href="https://medium.com/@ritikk/http-websockets-9c6704e44a2a" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on December 20, 2020.</p></footer></article></body></html>
