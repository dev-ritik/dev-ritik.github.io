---
title: Trust-TLS-SSL & HTTPS
date: 2020-05-17
layout: post
medium: https://medium.com/mobile-development-group/trust-tls-ssl-and-https-b925ac9d59
---
<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Trust! TLS-SSL and HTTPS</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">Trust! TLS-SSL and HTTPS</h1>
</header>
<section data-field="subtitle" class="p-summary">
How is the HTTP traffic secured? What does that lock indicate? How do we establish trust? How can I say that indeed this is the article I…
</section>
<section data-field="body" class="e-content">
<section name="9252" class="section section--body section--first section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="97ca" id="97ca" class="graf graf--h3 graf--leading graf--title">Trust! TLS-SSL and HTTPS</h3><p name="5db2" id="5db2" class="graf graf--p graf--hasDropCapModel graf--hasDropCap graf-after--h3"><span class="graf-dropCap">In</span> the last blog on <a href="https://medium.com/@ritikk/http-websockets-9c6704e44a2a" data-href="https://medium.com/@ritikk/http-websockets-9c6704e44a2a" class="markup--anchor markup--p-anchor" target="_blank">HTTP</a>, I explained the working and evolution of<a href="https://medium.com/@ritikkne/http-websockets-9c6704e44a2a" data-href="https://medium.com/@ritikkne/http-websockets-9c6704e44a2a" class="markup--anchor markup--p-anchor" target="_blank"> HTTP</a> towards better performance. As you might know, HTTP by itself isn’t secure. But that lock on the top left of your browser gives a sense of being safe on the internet. The Internet is a hostile place; my server’s access logs are the testimony!</p><blockquote name="f7bf" id="f7bf" class="graf graf--pullquote graf-after--p">How is the HTTP traffic secured? What does that lock indicate? How do we establish trust? How can I say that indeed this is the article I was supposed to read!? Is this genuinely medium.com??</blockquote><blockquote name="1b8d" id="1b8d" class="graf graf--blockquote graf-after--pullquote">I will explain the key concepts with examples related to them while trying to avoid as much technical jargon as possible.</blockquote><!--break--><p name="7afe" id="7afe" class="graf graf--p graf-after--blockquote"><strong class="markup--strong markup--p-strong">Prerequisites</strong></p><p name="9ea4" id="9ea4" class="graf graf--p graf-after--p">A bit of knowledge of network systems, particularly the TCP, and cryptography will be enough to understand the content. Though, an interest in the topic should suffice anyway!.</p><h3 name="3656" id="3656" class="graf graf--h3 graf-after--p">HTTPS??</h3><p name="95bc" id="95bc" class="graf graf--p graf-after--h3"><strong class="markup--strong markup--p-strong"><em class="markup--em markup--p-em">Hypertext Transfer Protocol Secure</em></strong><em class="markup--em markup--p-em"> </em>(<strong class="markup--strong markup--p-strong">HTTPS</strong>) is the secure version HTTP. HTTP, as the name suggests, sends data packets as hypertext. Anyone on the internet can easily read these, or hackers can impersonate your server upon using compromised routers like cafes and other public routers or easily tracked and modified by your ISPs. As such, critical information like banking details should not be handled without HTTPS. Even if you don’t host any sensitive data on your server, it’s pretty recommended shifting to HTTPS. (You don’t want an intermediary to modify your content like pushing their advertisements with it without your permission and your website down rated and marked insecure by popular browsers.)</p><p name="1824" id="1824" class="graf graf--p graf-after--p">HTTPS helps keep these malicious elements out by using what is called <strong class="markup--strong markup--p-strong">TLS/SSL Handshake</strong>, which happens before the actual data is transferred. The crux of this handshake is that your server and your client generate a shared session key using asymmetric cryptography, unique to the world, and then encrypt all the traffic to random data packets. Yes these packets can still be seen and modified by those sitting in the middle, or even the request can be forwarded to a malicious server, but your client software would know that something is wrong and alert the user to switch to a more secure network. How would they know you say? Well, that’s what this blog is all about.</p><h4 name="4f05" id="4f05" class="graf graf--h4 graf-after--p">How is HTTP related to HTTPS?</h4><p name="161f" id="161f" class="graf graf--p graf-after--h4">The actual messages are formatted and structured as determined by HTTP. It’s just that they are encrypted to garbage while transmitting and again decrypted by the intended recipient and none else. All HTTP data MUST be sent as TLS application data. By default, HTTP uses port 80 and HTTPS uses port 443.<strong class="markup--strong markup--p-strong"> </strong>Using HTTPS, only the source &amp; destination IP address, port and domain (SNI) are public. The URL, query parameters, headers, body, and cookies (which often contain identity information about the user) are all encrypted<strong class="markup--strong markup--p-strong">. </strong>The amount of data and the duration of communication can also be determined.</p><h4 name="1a75" id="1a75" class="graf graf--h4 graf-after--p">Making HTTPS calls using OpenSSL</h4><p name="8b4e" id="8b4e" class="graf graf--p graf-after--h4">OpenSSL is a command-line cryptography tool relating to SSL/TLS protocols and related cryptographic functions. As such, it can be easily used for making HTTPS calls. On your terminal,</p><pre name="9b90" id="9b90" class="graf graf--pre graf-after--p">openssl s_client -crlf -connect example.com:443<br>GET / HTTP/1.1<br>Host: example.com</pre><h4 name="6685" id="6685" class="graf graf--h4 graf-after--pre">Simple Example</h4><p name="943e" id="943e" class="graf graf--p graf-after--h4">Run the following code to fetch <em class="markup--em markup--p-em">example.com</em> using python. Comments have been added for your help.</p><figure name="81d4" id="81d4" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/dev-ritik/99609f5282a7cad5d13f621cd80431fe.js"></script><figcaption class="imageCaption">Example of a simple HTTPS request</figcaption></figure><h4 name="b59a" id="b59a" class="graf graf--h4 graf-after--figure">Capturing HTTPS and HTTP Packets</h4><p name="1c74" id="1c74" class="graf graf--p graf-after--h4">There are a handful of tools, particularly <a href="https://www.wireshark.org/" data-href="https://www.wireshark.org/" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank"><strong class="markup--strong markup--p-strong">Wireshark</strong></a>, which helps us analyse network packets actually exchanged. Let’s use a similar tool <strong class="markup--strong markup--p-strong">tcpdump</strong> to sniff and analyse these packets going to example.com (93.184.216.34). It can sniff all the packets on the target interface and help in analysing the traffic.</p><p name="e74c" id="e74c" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">HTTP:</strong> Let’s use <strong class="markup--strong markup--p-strong">cURL</strong> to make an HTTP request. Run this command on the terminal to capture packets:</p><pre name="7685" id="7685" class="graf graf--pre graf-after--p">tcpdump -A -n -s 0 host 3.220.159.10 and port http</pre><p name="ff07" id="ff07" class="graf graf--p graf-after--pre">Now, make an HTTP cURL request from another</p><pre name="8d73" id="8d73" class="graf graf--pre graf-after--p"><code class="markup--code markup--pre-code">curl --location &#39;http://postman-echo.com/post&#39; \<br>--data-raw &#39;This is a client secret, not to be revealed!&#39;</code></pre><p name="e2ed" id="e2ed" class="graf graf--p graf-after--pre">This would print the TCP packet in ASCII. If you like, you can get in hex as well. (You can interpret that packet using TCP segment structure as well). Anyways, here you can see among other things, src and dest address &amp; port. What you can also see is the first three messages of the <strong class="markup--strong markup--p-strong">TCP handshake</strong> (SYN, SYN+ACK, SYN). Following that you can see the entire HTTP request:</p><pre name="ed89" id="ed89" class="graf graf--pre graf-after--p">E....B@.@.. ..+#...<br>.D.P..EQ.t.............<br>.U....[.POST /post HTTP/1.1<br>Host: postman-echo.com<br>User-Agent: curl/7.58.0<br>Accept: */*<br>Content-Length: 44<br>Content-Type: application/x-www-form-urlencoded</pre><pre name="aa72" id="aa72" class="graf graf--pre graf-after--pre">This is a client secret, not to be revealed!</pre><p name="63e0" id="63e0" class="graf graf--p graf-after--pre">And after the server <code class="markup--code markup--p-code">ack</code>, the server reply as well:</p><pre name="8fe6" id="8fe6" class="graf graf--pre graf-after--p">E.. .a@…{….<br>..+#.P.D.t….F….n…….<br>..]T.U..HTTP/1.1 200 OK<br>Content-Type: application/json; charset=utf-8<br>Date: Tue, 28 Apr 2020 17:59:17 GMT<br>ETag: W/”189-BP2UptWJTIcEngOzrSrBUV1O57Y”<br>Server: nginx<br>set-cookie: sails.sid=s%3Anxu4rLgsmTVDxMM8s-9m8UvJ-RniOXlj.x4Jd80JEc2ldtbGd9KVKcnOP%2Bkspz0dYKduOgl4%2FXL0; Path=/; HttpOnly<br>Vary: Accept-Encoding<br>Content-Length: 393<br>Connection: keep-alive</pre><pre name="9ebb" id="9ebb" class="graf graf--pre graf-after--pre">{“args”:{},”data”:””,”files”:{},”form”:{“This is a client secret, not to be revealed!”:””},”headers”:{“x-forwarded-proto”:”https”,”host”:”postman-echo.com”,”content-length”:”44&quot;,”accept”:”*/*”,”content-type”:”application/x-www-form-urlencoded”,”user-agent”:”curl/7.58.0&quot;,”x-forwarded-port”:”80&quot;},”json”:{“This is a client secret, not to be revealed!”:””},”url”:”<a href="https://postman-echo.com/post" data-href="https://postman-echo.com/post" class="markup--anchor markup--pre-anchor" rel="nofollow noopener noopener noopener noopener" target="_blank">https://postman-echo.com/post</a>&quot;}</pre><p name="4e71" id="4e71" class="graf graf--p graf-after--pre">Following an ack by the client, you can see <strong class="markup--strong markup--p-strong">TCP Connection Termination</strong> as well.</p><blockquote name="5048" id="5048" class="graf graf--blockquote graf-after--p">The dump has other interesting things as well for your interpretation.</blockquote><p name="b864" id="b864" class="graf graf--p graf-after--blockquote">Take away here is that a middleman can sniff your complete HTTP request-response easily.</p><p name="d101" id="d101" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">HTTPS:</strong> Use Openssl for HTTPS and make the same request. Trace it using:</p><pre name="6c5c" id="6c5c" class="graf graf--pre graf-after--p">tcpdump -A -n -s 0 host 3.220.159.10 and port https</pre><p name="d104" id="d104" class="graf graf--p graf-after--pre">You will see a lot of messages exchanged, from both TCP Handshake and TLS Handshake. But you won’t find any more data than the TCP headers. HTTP data is encrypted to arbitrary bits.</p><h3 name="a782" id="a782" class="graf graf--h3 graf-after--p">SSL</h3><p name="5ecb" id="5ecb" class="graf graf--p graf-after--h3"><strong class="markup--strong markup--p-strong">Secure Sockets Layer (SSL)</strong>, more commonly called <strong class="markup--strong markup--p-strong">Transport Layer Security (TLS)</strong>, is a standard security protocol, commonly used by HTTPS, for securing the communication. Data is transferred over the public internet wherein it could easily be spoofed or sniffed if sent as plain text. SSL ensures that this transfer is encrypted using symmetric and asymmetric cryptography. Thus the data actually transferred is garbage to anyone else on the internet(planet) other than their intended recipient. (Even though they might never have met each other and are sitting on the other sides of the planet.)</p><p name="800a" id="800a" class="graf graf--p graf-after--p">This is done by what is called <strong class="markup--strong markup--p-strong">SSL Handshake</strong> and <strong class="markup--strong markup--p-strong">Certificate trust verification</strong>. This SSL protocol dictates how both parties should interact to ensure trust and authentication. All this is carried using what is called an <strong class="markup--strong markup--p-strong">SSL Certificate</strong>. This certificate packs a lot of data within it together with a <strong class="markup--strong markup--p-strong">public key</strong>. Please note that SSL is not limited to HTTPS. Other protocols like SMTP (for sending emails) are secured as well like SMTPS.</p><h4 name="3cc3" id="3cc3" class="graf graf--h4 graf-after--p">SSL Handshakes</h4><p name="13ce" id="13ce" class="graf graf--p graf-after--h4">To generate that unique session key for encryption, both parties need to agree on particulars of the conversation. So this Handshake is that pre-conversation agreement. During the Handshake, the following things happen:</p><ul class="postList"><li name="d02e" id="d02e" class="graf graf--li graf-after--p">Both parties agree on the protocol version.</li><li name="5395" id="5395" class="graf graf--li graf-after--li">Decide on the cypher suites to use</li><li name="32df" id="32df" class="graf graf--li graf-after--li">Prove the identity of the server (and the client if required)</li><li name="f53e" id="f53e" class="graf graf--li graf-after--li">Decide on the symmetric common session key for both parties</li></ul><figure name="1d86" id="1d86" class="graf graf--figure graf-after--li"><img class="graf-image" data-image-id="1*laui6VO02hZB1flJeggdHw.png" data-width="1257" data-height="659" alt="SSL Handshake" src="https://cdn-images-1.medium.com/max/800/1*laui6VO02hZB1flJeggdHw.png"><figcaption class="imageCaption">courtesy: <a href="https://techcommunity.microsoft.com/" data-href="https://techcommunity.microsoft.com/" class="markup--anchor markup--figure-anchor" rel="noopener" target="_blank">https://techcommunity.microsoft.com/</a></figcaption></figure><p name="c297" id="c297" class="graf graf--p graf-after--figure">Again, it all starts with a Socket based connection (A TCP handshake). The server is waiting on <code class="markup--code markup--p-code">accept</code>, i.e. waiting to accept a new TCP Socket connection and the client (browser) will <code class="markup--code markup--p-code">connect</code> soon. What happens during a socket connection (TCP Connection) is handled at the transport layer level. During the SSL Handshake, this is generally what happens:</p><ol class="postList"><li name="ae3b" id="ae3b" class="graf graf--li graf-after--p"><strong class="markup--strong markup--li-strong">Client Hello: </strong>The client sends a request for a secure connection with the server. It requests that the web server identify itself. It also includes other fields for initiating the agreement like supported versions and cyphers.</li><li name="1190" id="1190" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Server Hello: </strong>The server replies with its SSL certificate proving it’s identity. Note that the certificate also contains its public key. It also replies with some of its fields like selected version and cypher. It may ask for a client certificate request.</li><li name="7eed" id="7eed" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Authentication &amp; ClientKeyExchange: </strong>The client verifies the certificate received, through which it confirms that the server is indeed who it claims to be and the public key does genuinely belong to the server and not forged by someone on the public internet. (Again it’s all Cryptography!) The client, upon trusting the certificate and the public key, generates an asymmetric <strong class="markup--strong markup--li-strong">pre-master secret</strong> and sends it encrypted using the server’s public key. (Intelligent only that server can decrypt it using its Private key.)</li><li name="af0c" id="af0c" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Private key:</strong> The server decrypts the pre-master secret using its private key.</li><li name="7ebb" id="7ebb" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Session keys: </strong>Both client and server perform a series of steps depending upon the cypher and computes the <strong class="markup--strong markup--li-strong">session key</strong>. Hence, by the laws of cryptographic algorithms, they have shared a symmetric key which only these 2 devices on the planet claim to have and no other on the public internet (sorry MITM).</li><li name="6890" id="6890" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Finish:</strong> The server and the client acknowledge each other by sending a “finished” message that is encrypted with the session key!.</li></ol><p name="92fe" id="92fe" class="graf graf--p graf-after--li">The secure connection is thus established, and their communication is encrypted now.</p><p name="c669" id="c669" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">The exact steps may be slightly different based upon the cyphers and the version of the protocol used.</strong></p><blockquote name="f1b2" id="f1b2" class="graf graf--blockquote graf-after--p">Note that in this form of connection, the client certificate is not required. SSL verification of clients is also possible and required under some conditions wherein the server requires the client to verify as well! Well browsers don’t fit in those conditions.</blockquote><h4 name="4dfd" id="4dfd" class="graf graf--h4 graf-after--blockquote">Certificates</h4><p name="9d5f" id="9d5f" class="graf graf--p graf-after--h4">The SSL Certificate establishes the identity of an entity on the Internet. It is like a small document of trust wherein the entity records its public key and organisational details etc. The credibility of these certificates is established on the chain of trust anchored to the trusted authorities on the Internet using cryptographic wizardry!</p><p name="5fbb" id="5fbb" class="graf graf--p graf-after--p">Let’s get our hands dirty on these certificates!. There’s a lot to grab in them and let’s try to pocket some of them. It’s effortless to get the certificates of a web service. Using <strong class="markup--strong markup--p-strong">openssl</strong> is one such method. For <em class="markup--em markup--p-em">medium.com</em>, you can see the certificate using this command:</p><pre name="493d" id="493d" class="graf graf--pre graf-after--p">openssl s_client -showcerts -connect medium.com:443 &lt;/dev/null</pre><p name="782e" id="782e" class="graf graf--p graf-after--pre">Most popular browsers let you get these certificates as well.</p><p name="7441" id="7441" class="graf graf--p graf-after--p">Starting with a sample certificate!. In your browser, click on that lock symbol on the search bar and download Medium’s certificate, it used to negotiate an SSL connection with your browser. This is how it looks now:</p><pre name="ec5d" id="ec5d" class="graf graf--pre graf-after--p">-----BEGIN CERTIFICATE-----MIIHOjCCBiKgAwIBAgIQCKfj9u8gdru4ZGLwtU+igTANBgkqhkiG9w0BAQsFADB1</pre><pre name="ad10" id="ad10" class="graf graf--pre graf-after--pre">&lt;Base64 Encoded text&gt;</pre><pre name="4b84" id="4b84" class="graf graf--pre graf-after--pre">4JrHEaQHgEi13M29EUMqB3azOqcov4m1QZH0ygih6UFPol0+InswHa84ZTDmPOpt<br>gSl68MrGmFqTfywSCfStLmMZJWjfW/3OHFzvGMX2<br>-----END CERTIFICATE-----</pre><p name="caac" id="caac" class="graf graf--p graf-after--pre">This looks like a lot of base64 encoded gibberish but saves this in a file <code class="markup--code markup--p-code">medium.crt</code> and run the command,</p><pre name="88bd" id="88bd" class="graf graf--pre graf-after--p">openssl x509 -in medium.crt -text -noout</pre><p name="93ad" id="93ad" class="graf graf--p graf-after--pre">You can see all the details it has within itself. Among other things, it contains,</p><p name="fc65" id="fc65" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code u-paddingRight0 u-marginRight0">Issuer: C = US, O = DigiCert Inc, OU = <a href="http://www.digicert.com" data-href="http://www.digicert.com" class="markup--anchor markup--p-anchor" rel="nofollow noopener noopener noopener noopener" target="_blank">www.digicert.com</a>, CN = DigiCert SHA2 Extended Validation Server CA</code></p><p name="e205" id="e205" class="graf graf--p graf-after--p">Indicating that <code class="markup--code markup--p-code">DigiCert SHA2 Extended Validation Server CA</code> issued medium this certificate and</p><p name="eff5" id="eff5" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">Subject: businessCategory = Private Organization, jurisdictionC = US, jurisdictionST = Delaware, serialNumber = 5010624, C = US, ST = California, L = San Francisco, O = A Medium Corporation, CN = medium.com</code></p><p name="2d59" id="2d59" class="graf graf--p graf-after--p">is the description of the entity(medium) it is issued to. <br>Now if you download <code class="markup--code markup--p-code">DigiCert SHA2 Extended Validation Server CA</code>‘s certificate and run similar command, this is what you get:<br><code class="markup--code markup--p-code u-paddingRight0 u-marginRight0">Issuer: C = US, O = DigiCert Inc, OU = <a href="http://www.digicert.com" data-href="http://www.digicert.com" class="markup--anchor markup--p-anchor" rel="nofollow noopener noopener noopener noopener" target="_blank">www.digicert.com</a>, CN = DigiCert High Assurance EV Root CA</code></p><p name="e06b" id="e06b" class="graf graf--p graf-after--p">Indicating that this itself was issued by <code class="markup--code markup--p-code">DigiCert High Assurance EV Root CA</code>. You can see a chain like trust-building! Upon downloading this one, you will see that issuer is the same as the one to whom it is issued to,</p><pre name="5930" id="5930" class="graf graf--pre graf-after--p">Issuer: C = US, O = DigiCert Inc, OU = <a href="http://www.digicert.com" data-href="http://www.digicert.com" class="markup--anchor markup--pre-anchor" rel="nofollow noopener noopener noopener noopener" target="_blank">www.digicert.com</a>, CN = DigiCert High Assurance EV Root CA<br> Validity<br> Not Before: Nov 10 00:00:00 2006 GMT<br> Not After : Nov 10 00:00:00 2031 GMT<br> Subject: C = US, O = DigiCert Inc, OU = <a href="http://www.digicert.com" data-href="http://www.digicert.com" class="markup--anchor markup--pre-anchor" rel="nofollow noopener noopener noopener noopener" target="_blank">www.digicert.com</a>, CN = DigiCert High Assurance EV Root CA</pre><figure name="9522" id="9522" class="graf graf--figure graf-after--pre"><img class="graf-image" data-image-id="1*L1wDi5EVmQHhWmQx6pu6tw.png" data-width="675" data-height="547" src="https://cdn-images-1.medium.com/max/800/1*L1wDi5EVmQHhWmQx6pu6tw.png"><figcaption class="imageCaption">Medium certificate chain</figcaption></figure><p name="4b86" id="4b86" class="graf graf--p graf-after--figure">So should we trust <code class="markup--code markup--p-code">DigiCert High Assurance EV Root CA</code> and by extension medium!? Well yes! They are the trust anchors (<strong class="markup--strong markup--p-strong">Certifying Authorities</strong>) of the internet trust network, and mostly every SSL software keeps a copy of these certificates or gets it through support libraries. They have to comply with the set of security guidelines established by these Softwares (like Browsers). As can be seen here, certificates are generally signed by other certificates forming the<strong class="markup--strong markup--p-strong"> certificate chain</strong>. This chain terminates at a self-signed authoritative certificate provided by these root <strong class="markup--strong markup--p-strong">Certifying Authorities</strong> (CA)s like Digicert Root CA. There are cryptographic algorithms to ensure that if certificates are indeed signed by the issuer (discussed later).</p><p name="251c" id="251c" class="graf graf--p graf-after--p">Also, if you are following along using openssl, you must have noted that medium doesn’t actually send this root certificate. The browser itself, in fact, adds it. The server may not send the root CA certificate if it wants to. (<a href="https://tools.ietf.org/html/rfc5246#section-7.4.2" data-href="https://tools.ietf.org/html/rfc5246#section-7.4.2" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">RFC Reference</a>).</p><p name="4ef6" id="4ef6" class="graf graf--p graf-after--p">You can also verify the certificate chain using openssl. As explained in the picture above, Issuer (Digicert CA) signs the certificate containing the public key of the requester (Medium). It uses it’s own private key to generate a cryptographic signed hash of the data provided with the request and sends that in the certificate. Now cryptography says that only Digicert’s public key can decrypt it, which is available with its own certificate. So let’s get</p><ul class="postList"><li name="7605" id="7605" class="graf graf--li graf-after--p"><strong class="markup--strong markup--li-strong">Digicert pubkey</strong>: To get the included Digicert’s public key from its certificate use</li></ul><pre name="5557" id="5557" class="graf graf--pre graf-after--li">openssl x509 -pubkey -noout -in DigiCert\ SHA2\ Extended\ Validation\ Server\ CA.crt &gt; DigiCert.pub</pre><ul class="postList"><li name="c5d3" id="c5d3" class="graf graf--li graf-after--pre"><strong class="markup--strong markup--li-strong">Medium signature from the certificate:</strong> You can extract the Digicert signed hash in the medium’s certificate and convert it into binary:</li></ul><pre name="e874" id="e874" class="graf graf--pre graf-after--li">openssl x509 -in medium.crt -text -noout -certopt ca_default -certopt no_validity -certopt no_serial -certopt no_subject -certopt no_extensions -certopt no_signame | grep -v ‘Signature Algorithm’ | tr -d ‘[:space:]:’ | xxd -r -p &gt; medium_signature.bin</pre><ul class="postList"><li name="beb8" id="beb8" class="graf graf--li graf-after--pre"><strong class="markup--strong markup--li-strong">Cert body:</strong> To get the body of the cert which was actually hashed,</li></ul><pre name="0692" id="0692" class="graf graf--pre graf-after--li"><code class="markup--code markup--pre-code">openssl asn1parse -in </code>medium.crt<code class="markup--code markup--pre-code"> -strparse 4 -out cert-body.bin</code></pre><p name="f776" id="f776" class="graf graf--p graf-after--pre">Finally, run the command (sha256 in this case),</p><pre name="d6d6" id="d6d6" class="graf graf--pre graf-after--p">openssl dgst -sha256 -verify DigiCert.pub -signature medium_signature.bin cert-body.bin <br>&gt;&gt;&gt;&gt; Verified OK</pre><p name="8063" id="8063" class="graf graf--p graf-after--pre">This shows that Digicert CA actually signed the medium’s cert and everything in medium’s cert (including medium’s public key) is actually genuine if Digicert’s certificate is genuine. This certificate chain of trust is the backbone of trust on the internet. More details on this can be found <a href="https://kulkarniamit.github.io/whatwhyhow/howto/verify-ssl-tls-certificate-signature.html" data-href="https://kulkarniamit.github.io/whatwhyhow/howto/verify-ssl-tls-certificate-signature.html" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">here</a>. This was just signature verification, but other things like validity and revoking trust check also comes into play.</p><p name="fb68" id="fb68" class="graf graf--p graf-after--p">Where to look for the certificates I trust? Softwares like your OS comes with its list of trusted anchors.</p><ul class="postList"><li name="6794" id="6794" class="graf graf--li graf-after--p">For Linux, the file <code class="markup--code markup--li-code">/etc/ssl/certs/ca-certificates.crt</code> contains the concatenated list of trusted CA’s certificates which defines the base trust for your OS and other software which use that file as default.</li><li name="ae93" id="ae93" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">requests</code> library in python has <a href="https://github.com/psf/requests/blob/master/requests/certs.py" data-href="https://github.com/psf/requests/blob/master/requests/certs.py" class="markup--anchor markup--li-anchor" rel="noopener" target="_blank">this</a> file wherein it looks for the root CA certs. You can see that it depends on the <code class="markup--code markup--li-code">certifi</code> package. This package contains updated root CA certificates for major trust anchors. (Like if you see their PyPI page, ‘<em class="markup--em markup--li-em">Python package for providing Mozilla’s CA Bundle’</em>). Certifi comes with its list of certs when downloaded, available <a href="https://github.com/certifi/python-certifi/blob/master/certifi/cacert.pem" data-href="https://github.com/certifi/python-certifi/blob/master/certifi/cacert.pem" class="markup--anchor markup--li-anchor" rel="noopener" target="_blank">here</a>.</li><li name="c5ec" id="c5ec" class="graf graf--li graf-after--li">In python<code class="markup--code markup--li-code">urllib3</code>, it says <a href="https://urllib3.readthedocs.io/en/latest/user-guide.html#certificate-verification" data-href="https://urllib3.readthedocs.io/en/latest/user-guide.html#certificate-verification" class="markup--anchor markup--li-anchor" rel="noopener" target="_blank">here</a> that, ‘<em class="markup--em markup--li-em">Unless otherwise specified urllib3 will try to load the default system certificate stores. The most reliable cross-platform method is to use the </em><a href="https://certifi.io/" data-href="https://certifi.io/" class="markup--anchor markup--li-anchor" rel="noopener" target="_blank"><em class="markup--em markup--li-em">certifi</em></a><em class="markup--em markup--li-em"> package which provides Mozilla’s root certificate bundle</em>’.</li><li name="0e43" id="0e43" class="graf graf--li graf-after--li">For chrome, go to <code class="markup--code markup--li-code">chrome://settings/certificates</code> onto the <code class="markup--code markup--li-code">Authorities</code> tab, and search for DigiCert, you will get <code class="markup--code markup--li-code">DigiCert High Assurance EV Root CA</code> there. If you compare these two, they are actually the same! Hence Chrome establishes trust for this certificate for you! And hence you see that green lock there on the search bar!. You can get it on the Firefox as well!.</li></ul><p name="c130" id="c130" class="graf graf--p graf-after--li">Look how chrome complained when I denied chrome to use that certificate to verify medium! XD</p><figure name="34d8" id="34d8" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*w8N3NJj2mM7Pn04zl6rGOw.png" data-width="517" data-height="322" src="https://cdn-images-1.medium.com/max/800/1*w8N3NJj2mM7Pn04zl6rGOw.png"><figcaption class="imageCaption">Manually removing trust for Digicert Root CA.</figcaption></figure><figure name="6ff9" id="6ff9" class="graf graf--figure graf-after--figure"><img class="graf-image" data-image-id="1*k50HRAAfoECt7OiAFPDxDg.png" data-width="187" data-height="35" src="https://cdn-images-1.medium.com/max/800/1*k50HRAAfoECt7OiAFPDxDg.png"><figcaption class="imageCaption">Not Secure Warning on the search bar</figcaption></figure><figure name="f095" id="f095" class="graf graf--figure graf-after--figure"><img class="graf-image" data-image-id="1*iqCIxpXSNkgfjAw22I4Itw.png" data-width="633" data-height="676" data-is-featured="true" src="https://cdn-images-1.medium.com/max/800/1*iqCIxpXSNkgfjAw22I4Itw.png"><figcaption class="imageCaption">NET::ERR_CERT_AUTHORITY_INVALID</figcaption></figure><p name="1cb6" id="1cb6" class="graf graf--p graf-after--figure">Let me explain what just happened. During SSL handshake, Medium didn’t provide all the 3 certificates! It just provided its own certificate, cryptographically signed by DigiCert SHA2 Extended Validation Server CA bundled with the latter’s certificate signed by DigiCert High Assurance EV Root CA. But since Chrome now doesn’t trust this Root CA, it cannot guarantee the user if it is indeed medium. It may be any malicious website pretending to be medium and proceeding further is probably unsafe.</p><p name="c74b" id="c74b" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Let me describe another case</strong>. Consider that the server doesn’t send its certificate chain and rather send the leaf certificate (signed by an intermediate authority and not directly by your trusted root CA). What happens then!. Well, it all depends upon the implementation of the certificate verification program. Certificates contain fields (along with Issuer DN (Distinguished Name)<strong class="markup--strong markup--p-strong"> </strong>mentioned above) which help the program to fetch that intermediate certificate from other sources. This may be utilised to fetch and build the chain and hence build trust. Chrome does this automatically for you, but firefox probably gives a warning. But for libraries like python request, this isn’t the case. You will certainly get verification errors in this case! Here, a temporary solution will be to add intermediate certificates yourself as trusted (for the time being).</p><h4 name="b31e" id="b31e" class="graf graf--h4 graf-after--p">Simple Example</h4><p name="1e57" id="1e57" class="graf graf--p graf-after--h4">To get the simplest SSL based communication, you would need a certificate for the server, which can be verified by our demo client. This is explained beautifully <a href="https://www.electricmonk.nl/log/2018/06/02/ssl-tls-client-certificate-verification-with-python-v3-4-sslcontext/" data-href="https://www.electricmonk.nl/log/2018/06/02/ssl-tls-client-certificate-verification-with-python-v3-4-sslcontext/" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">here</a>.</p><p name="cdae" id="cdae" class="graf graf--p graf-after--p">For experimenting with different types of certificates, have a look at <a href="https://badssl.com/" data-href="https://badssl.com/" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">this website</a>.</p><h4 name="f223" id="f223" class="graf graf--h4 graf-after--p">How to get a certificate for my website?</h4><figure name="aa45" id="aa45" class="graf graf--figure graf--layoutOutsetLeft graf-after--h4"><img class="graf-image" data-image-id="1*xiAYdN-ELzSMC3vfYZ3EgQ.png" data-width="682" data-height="613" src="https://cdn-images-1.medium.com/max/600/1*xiAYdN-ELzSMC3vfYZ3EgQ.png"><figcaption class="imageCaption">Self-Signed Certificates!</figcaption></figure><p name="aeff" id="aeff" class="graf graf--p graf-after--figure">As you must have guessed by now, you can indeed generate your own <strong class="markup--strong markup--p-strong">self-signed certificate</strong> and use that to establish yourself as the trust anchor for your closed testing environment. But that won’t work in production. Your users won’t trust your signed certificate. Instead, browsers and search engines will demote your website. Indeed your communication will be secure though! (<em class="markup--em markup--p-em">assuming that it is with your server and not any other impersonated server!</em>)</p><p name="243a" id="243a" class="graf graf--p graf-after--p">You would obviously try to get certificates from established trust anchors on the internet. Now there are tons of CA on the internet both paid and free ones. I personally use <a href="https://letsencrypt.org/" data-href="https://letsencrypt.org/" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank"><strong class="markup--strong markup--p-strong">Let’s Encrypt</strong></a> for my websites (<em class="markup--em markup--p-em">not a paid promotion!</em>). It’s free and easy to use. <em class="markup--em markup--p-em">To get a certificate for your website’s domain from Let’s Encrypt, you have to demonstrate control over the domain.</em> Assuming that you are hosting your service on some virtual servers like AWS yourself, it basically boils down to your server listening to the IP address attached to your domain and you having SSH access into the system. It comes with a handy tool called <a href="https://certbot.eff.org/" data-href="https://certbot.eff.org/" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">certbot</a>. <em class="markup--em markup--p-em">It can automate certificate issuance and installation with no downtime. </em>For my website, I have automated the process using these shell commands:</p><pre name="4a4b" id="4a4b" class="graf graf--pre graf-after--p">$ wget <a href="https://dl.eff.org/certbot-auto;" data-href="https://dl.eff.org/certbot-auto;" class="markup--anchor markup--pre-anchor" rel="noopener" target="_blank">https://dl.eff.org/certbot-auto;</a> chmod a+x certbot-auto<br>$ sudo ./certbot-auto certonly -- non-interactive -- email &lt;email&gt; -- agree-tos -- standalone -- domains &lt;domain&gt; -- keep-until-expiring -- debug<br>$ sudo ln -sf /etc/letsencrypt/live/&lt;domain&gt; /etc/letsencrypt/live/cert</pre><p name="f69f" id="f69f" class="graf graf--p graf-after--pre">This generates a cert and private key for your website and stores the Let’s encrypt intermediate cert as well for the trust chain at <code class="markup--code markup--p-code">/etc/letsencrypt/live/cert/</code> . Now you could easily add their location to Nginx or Apache(httpd) server config file or use them with the simple HTTPS example mentioned above.</p><h4 name="a46c" id="a46c" class="graf graf--h4 graf-after--p">Conclusion</h4><p name="8709" id="8709" class="graf graf--p graf-after--h4">Wooh that was too much of content! I hope you have understood these standard concepts. TLS is indeed interesting! It has many other aspects and a lot of cryptography involved!. I have added some of my examples here. Go ahead and play and learn as you like. Check out the following repository demonstrating implementation based on the stuff explained above.</p><div name="b641" id="b641" class="graf graf--mixtapeEmbed graf-after--p graf--trailing"><a href="https://github.com/dev-ritik/Secure-file-transfer" data-href="https://github.com/dev-ritik/Secure-file-transfer" class="markup--anchor markup--mixtapeEmbed-anchor" title="https://github.com/dev-ritik/Secure-file-transfer"><strong class="markup--strong markup--mixtapeEmbed-strong">dev-ritik/Secure-file-transfer</strong><br><em class="markup--em markup--mixtapeEmbed-em">A demonstration for secure file transfer within an organization using key-chain validation. The files are secured using asymmetric encryption…</em>github.com</a><a href="https://github.com/dev-ritik/Secure-file-transfer" class="js-mixtapeImage mixtapeImage u-ignoreBlock" data-media-id="3b9c3e95917196aa53364c325f47cc45" data-thumbnail-img-id="0*6uLa7h9mdRZCXAI3" style="background-image: url(https://cdn-images-1.medium.com/fit/c/160/160/0*6uLa7h9mdRZCXAI3);"></a></div></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@ritikk" class="p-author h-card">Ritik kumar</a> on <a href="https://medium.com/p/b925ac9d59"><time class="dt-published" datetime="2020-05-17T17:13:36.168Z">May 17, 2020</time></a>.</p><p><a href="https://medium.com/@ritikk/trust-tls-ssl-and-https-b925ac9d59" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on December 20, 2020.</p></footer></article></body></html>
